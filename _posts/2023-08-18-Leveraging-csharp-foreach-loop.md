---
layout: post
read_time: true
show_date: true
title: "Efficient Data Processing: Leveraging C#'s foreach Loop"
date: 2023-08-18
img_path: /assets/img/posts/20230818
image: Casa-do-Alentejo.jpg
tags: [development, .net, csharp, performance]
category: development
---

In the dynamic landscape of modern software development, efficient data processing lies at the core of creating high-performance applications. As developers, we constantly strive to balance readability, maintainability, and speed when writing code. In the realm of C#, a programming language known for its versatility and robustness, the `foreach` loop emerges as a powerful tool for seamlessly navigating collections.

`foreach`` is a statement in C# that generates the code required to traverse the items of a collection. The syntax is very simple:

```csharp
foreach(var item in source)
{
    Console.WriteLine(item);
}
```

This article will focus on the code that is generated by the compiler given various types of collections so that you can understand exactly what your application is doing when you use this type of loop.

## Minimum requirements

For the `foreach` statement to accept a collection as its source, the collection must provide a public parameterless method named `GetEnumerator()` that returns a new instance of a enumerator object. The enumerator must then provide a public parameterless method named `MoveNext()` that returns a boolean and also a public property named `Current`.

The enumerator must maintain the state of the enumeration. The method `MoveNext()` should return `true` if a next item is available; otherwise `false`. The property `Current` should return the item at the current position.

As an example, here's a collection that stores its items in an inner array and that implements the minimum required to be traversed using a `foreach` statement:

```csharp
class MyCollection
{
    readonly int[] source;

    public MyCollection(int[] source)
        => this.source = source;

    public Enumerator GetEnumerator()
        => new Enumerator(this);

    public struct Enumerator
    {
        readonly int[] source;
        int index;

        public Enumerator(MyCollection enumerable)
        {
            source = enumerable.source;
            index = -1;
        }

        public int Current
            => source[index];

        public bool MoveNext()
            => ++index < source.Length;
    }
}
```

> The enumerator should always be a struct (a value-type) for improved performance! Check my other article "[Performance of value-type vs reference-type enumerators in C#](https://www.linkedin.com/pulse/performance-value-type-vs-reference-type-enumerators-ant%C3%A3o-almada?lipi=urn%3Ali%3Apage%3Ad_flagship3_pulse_read%3BACD%2BUgenSQC%2FUZMFSw%2BoCQ%3D%3D)" to understand why.

The compiler converts the C# code into [Intermediate Language (IL)](https://en.wikipedia.org/wiki/Common_Intermediate_Language). There is no `foreach` instruction in IL. [Using SharpLab, you can see that in this case the `foreach` is converted to something equivalent to the following](https://sharplab.io/#v2:EYLgxg9gTgpgtADwGwBYA+ABATABgLABQ2AjIYQG4CGUABAM4QCuUYMNAvDQHYwDuNAWQCeAYQgAbcTDAAXAJYQuACh68A2gF0aAbxwAaGsQNYDAZgMoAvgEoA3IQBm0GJTAALJVVpyZMALY0clz0TCww1oQ0UTQYxACcSj7+dmREWIKiElKyClyE2pHRsJQAJoriQoFcMpohzKz2BNE0hVEYphliktLyionVtQz14a3NHAB8NDJucnQAdENhHHVhjc2j7TQAolyMfjBQlDLQNADiMDI7ewdH0EoRTWNR7JOq27v7h8dQStOzKY8ohsOnQZFBGLJ3tcvtBRgVAWNimUuBUqjUtIsGqNmkEZFUSjAEGsni0Ec1NldPrcfsIutlesEYB8bsApA8STpsSTMWxOEzoZRWTAFqEsWSSUECQhlnBiMSnpYuUDxW0OriaCJmLBqqSOc0XitWGpJYSNPKxkqYh1gBAJIIIOQYAA5Qkye6W/WTADUXpN0oAPIbhQAZJkAc2m5sVBGjhCAA===):

```csharp
MyCollection.Enumerator enumerator = new MyCollection(array).GetEnumerator();
while (enumerator.MoveNext())
{
    Console.WriteLine(enumerator.Current);
}
```

It first calls `GetEnumerator()` to get a new instance of the enumerator. It then uses `MoveNext()` as the continuation condition in a `while` loop and, for every time it returns `true`, gets the item using `Current`.

If the enumerator must release any resources at the end of the item traversal, it must implement `IDisposable`. [You can see in SharpLab that in this case the generated code will make sure `Dispose()` is called](https://sharplab.io/#v2:EYLgxg9gTgpgtADwGwBYA+ABATABgLABQ2AjIYQG4CGUABAM4QCuUYMNAvDQHYwDuNAWQCeAYQgAbcTDAAXAJYQuACh68A2gF0aAbxwAaGsQNYDAZgMoAvgEoA3IQBm0GJTAALJVVpyZMALY0clz0TCww1oQ0UTQYxACcSj7+dmREWIKiElKyClyE2pHRsJQAJoriQoFcMpohzKz2BNE0hVEYphliktLyionVtQz14a3NHAB8NDJucnQAdENhHHVhjc2j7TQAolyMfjBQlDLQNADiMDI7ewdH0EoRTWNR7JOq27v7h8dQStOzKY8ohsOnQZFBGLJ3tcvicQDQAJIAEVmAAcIHRKMApKMCoCxsUylwKlUalpFg1Rs0gjIqiUYAg1k8Wnjmpsrp9bj9hF1sr1gjAPjcsSMWdFcUyxuS2JwBdDMVIFqEKaKnkE6QhlnBiIynpZKdF9W0OtSaCJmLBqsyJc0XitWGo1fSNDqxoaYh1gBAJIIIOQYAA5ekye5um2TADU4cdGoAPHaYHMADICgDm0xd6xV7piKBoyLoaLoMHuOj1eLLZcIQA==):

```csharp
MyCollection.Enumerator enumerator = new MyCollection(array).GetEnumerator();
try
{
    while (enumerator.MoveNext())
    {
        Console.WriteLine(enumerator.Current);
    }
}
finally
{
    ((IDisposable)enumerator).Dispose();
}
```

## Returning items by reference

The `foreach` statement supports returning the items by reference. Passing items by reference improves the performance when traversing collection containing large structs as it will not copy each of the items. It will simply pass a reference to each of them.

For example, we can change the `Current` property to return `ref int`:

```csharp
class MyCollection
{
    readonly int[] source;

    public MyCollection(int[] source)
        => this.source = source;

    public Enumerator GetEnumerator()
        => new Enumerator(this);

    public struct Enumerator
    {
        readonly int[] source;
        int index;

        public Enumerator(MyCollection enumerable)
        {
            source = enumerable.source;
            index = -1;
        }

        public ref int Current // return by reference
            => ref source[index];

        public bool MoveNext()
            => ++index < source.Length;

        public void Dispose() {}
    }
}
```

In this case, `Current` returns a reference to the position where the item is stored. This way, you can both initialize the values for a `MyCollection` instance using a `foreach` and also list its items to the console:

```csharp
var source = new MyCollection(new int[10]);

// initialize all to ones
foreach(ref var item in source)
    item = 1;

// output to console
foreach(ref readonly var item in source)
    Console.WriteLine(item);
```

Notice the `ref` keyword in the first `foreach` so that the item value can be changed. The second `foreach` uses the `ref readonly` keywords so that a new value cannot be assigned to the item. [You can see it working in SharpLab](https://sharplab.io/#v2:EYLgxg9gTgpgtADwGwBYA0AXEUCuA7AHwAEAmABgFgAoUgRmuoDcBDKAAgGcIcowY2AvGzwwA7mwCyATwDCEADbyYYDAEsIeABQjxqvBgDatMgF0AlAG4GVAGbQYzMAAtNsG2xbtVGGAFs2epzcvDBm1GwRAT7+QrRWVNR2sI4ubmzJACYa8lIerFF+AXhBPHxhVJFsRLQAnJrefpbWpJKyCkoq6njUAN7hkZnZuXqGJiUh8ZX9EUQAzK1yispqGvX6BmNcpaHTlYIAfGwYTqocAHRbIYLjfJORu3NsAKJ4OL4wUMwY0GwA4jAYF5vD5faCacp7SICQ46Z6vd6fb5QTTHU5NCr3DEzeYcDC4FRw4GI6C7PpYvaDPA5IqjG4wO6QkZFDIwBAMva7SqPIEI0HI6SLDorYoweEg4BKCGQthk6V7S58a6ionMCUwC7BW6c6V6FkIa5wOLaiIAX2NbHNjzSTJkPFg+gt5Ll0PSMHcCpgBl1rJM7KmTsij2AEAUkggjBgADlWRhwebKi6ANSJ736gA8dLOABlRQBzY5+zFyx5EFBsAAipwADhAODBwTKzeSm03qEA=).

The `Current` property can be changed to return `ref readonly` making it impossible to assign value to the items.

If you'd like the enumerator to contain a span field, it's possible to declare the enumerator as a `ref struct`. The example collection can be implemented as follow:

```csharp
class MyCollection
{
readonly int[] source;

    public MyCollection(int[] source)
        => this.source = source;

    public Enumerator GetEnumerator()
        => new Enumerator(this);

    public ref struct Enumerator // ref struct enumerator
    {
        readonly ReadOnlySpan<int> source; // readonly span field
        int index;

        public Enumerator(MyCollection enumerable)
        {
            source = enumerable.source;
            index = -1;
        }

        public ref readonly int Current // return by reference
            => ref source[index];

        public bool MoveNext()
            => ++index < source.Length;

        public void Dispose() {}
    }

}
```

[You can see it working in SharpLab](https://sharplab.io/#v2:EYLgxg9gTgpgtADwGwBYA0AXEUCuA7AHwAEAmABgFgAoUgRmuoDcBDKAAgGcIcowY2AvGzwwA7mwCyATwDCEADbyYYDAEsIeABQjRAbQC6bAN5k0bWmZJmAzGZQBfAJQBuagDNoMZmAAWmluyqGDAAtmyqeJzcvDCO1GwJbES0AJyaQaEuDDQkkrIKSirqeNRG8YmwzAAmGvJS4XgYBlE8fK5UiWzlCUTWeXKKymoa6Y3NXK2x3Z2CAHxsGD6qHAB0EzGCLTHtndO9bACieDghMFDMGNBsAOIwGEcnZxfQmnEdMwkC8zqHx6fnlygmkWyyy7wSez6sDcnAwuBUv0eAOg0zK4JmlRqeDqbAASl4qgB5bFSADKAAdmHgADwRDDzdZtaadOkNKowBA7D5ddGdfYPf7PIHSAaFYaRGB/J7AJRvbnGZncxn8ISSpHMGUwNbRJm87kRdkITZwWhcj72RUQvU9KEwGGY2r1VkyHiwRo8+WdL5saFbPi6A0c/RmmaWpJ9YAQBSSCCMGAAOQ5GFeYa98wA1OnA0bqX6tQAZSUAc0WId21vDSRQbAAIstyRAODBXsYLei223qEA===).

> A ref struct cannot implement interfaces. In this case, `foreach` will call the Dispose() method if present. Without requiring the enumerator to implement IDisposable.

## GetEnumerator() extension method

Starting from C# 6, `foreach` also supports the use of `GetEnumerator()` as an extension method.
Imagine that you'd like to use `foreach` on the following collection developed by a third-party:

```csharp
public class MyCollection
{
    readonly int[] source;

    public MyCollection(int[] source)
        => this.source = source;

    public int Count
        => source.Length;

    public int this[int index]
        => source[index];
}
```

This collection provides an indexer and a `Count` property that returns the number of items. If you try to use `foreach` on it, the compilation will fail.

You can then define the following extension method for the collection:

```csharp
public static class MyExtension
{
    public static Enumerator GetEnumerator(this MyCollection source)
        => new Enumerator(source);

    public struct Enumerator
    {
        readonly MyCollection source;
        int index;

        public Enumerator(MyCollection source)
        {
            this.source = source;
            index = -1;
        }

        public int Current
            => source[index];

        public bool MoveNext()
            => ++index < source.Count;
    }
}
```

[You can see in SharpLab that the `foreach` statement compiles](https://sharplab.io/#v2:EYLgxg9gTgpgtADwGwBYA+ABATABgLABQ2AjIYQG4CGUABAM4QCuUYMNAvDQHYwDuNAWQCeAYQgAbcTDAAXAJYQuACh68A2gF0aAbxwAaGsQNYDAZgMoAvgEoA3IQBm0GJTAALJVVpyZMALY0clz0TCww1oQ0UTQYxACcSj7+dmREpjFYgqISUrIKXITakdGwlAAmiuJCgVwymiHMrPYE0TTFURjpwmKS0vKKibX1DI3h7a0cAHw0Mm5ydAB0I2EcDWHNreOdNTI0Yoy1463s08usCwAyMFwA5rMb0VvpQbuz82ovNWUwCBpH0Sc1qwPlxvr9mpZUttYkgMlkAKIIXxcOj5OiFJ4xYiw+FcRh+GBQSgyaA0ADiMBkuPxhOJ0CUbzoWR6uX6wTOYxaEyigNUNGpBKJJKgSg5KS5UUxdBkUEYsn5eMFdKg4yKEompQqXCqzJyfXyQJgD25nyCYONE3+HXSAtpwqU3T1eUUhoi6taau53MZS1CrFWHItXq+P1WcGIQeikPdjxj1p2e2YsFqbTjE0BHJBYI0tmDVtTwe2wAgEkEEHIMAAcj8ZEo3cHjtMANRNs2hgA8hoW+1qFuj0cIQA===). You can also see that the generated code is very similar. The only difference is that it uses the extension method:

```csharp
MyExtensions.Enumerator enumerator = MyExtensions.GetEnumerator(new MyCollection(array))
while (enumerator.MoveNext())
{
    Console.WriteLine(enumerator.Current);
};
```

[You can see in SharpLab that the same applies to `GetAsyncEnumerator()`](https://sharplab.io/#v2:EYLgxg9gTgpgtADwGwBYA0AXEUCuA7AHwAEAmABgFgAoUgRmqLIAIjaBWAbmuoDcBDKEwDOEHFDAwmAXiZ4YAdyYBZAJ4BhCABtNMMBgCWEPAAo58gNoBdJgG8yaJrQckHAZgcoAvgEouNAJxMAGbQMHxgABbG/IL6GDAAtkz6eMKi4jDe1Ew5LLT+xnGJvtw0riwkyupaOnqGeNQ22bmwfAAmRpoqyXgYVmliEn65TM05ROWqGtq6BkaFvf0ig5ljI9IAfEwYEfpCAHTLGdIDGcO5axM9GEwa+BhrI1JbRxL7ADIweADmO+c5l3KKRuOz25mBPTaMAQlkeuWepwk4LwUJhfk8pSurCQFSqAFEEPE8EJ6kJGoC8ji8XgcAkYFA+BhoEwAOIwDAAQSEKjwYGptPpjOgxlBQiq01qc1Sr1WVHW8K2ZiY/LpDKZUGMMpKcouOvG5SEGFwemVNNVQqgayaevWrQ6eC64pqs3qiJg/3WEJSqI9Izh+tNArVwqmzrqRjdWRtI2t8vlosO6QkJxlvrj3uhJzgtDTOQx0d1cZYQN6tzEsFL/vWCJlyNRlg4RarVauADU+JocDAiEgADzACBaLZKCA8GAAOWhnO5vOMUaLTy27c73aQ+wAYlAIAkAEowIQ4TQYYwAahPGYQTF7bv2d162pG+fz1CAA===).

## IEnumerable

`IEnumerable` is an interface defined in the namespace `System.Collections` that actually enforces the pattern required by the `foreach` statement. So, any type that implements `IEnumerable` can be traversed using the `foreach` statement.

As an example, here's the sample collection now implementing `IEnumerable`:

```csharp
class MyCollection : IEnumerable
{
    readonly int[] source;

    public MyCollection(int[] source)
        => this.source = source;

    public IEnumerator GetEnumerator()
        => new Enumerator(this);

    public struct Enumerator : IEnumerator
    {
        readonly int[] source;
        int index;

        public Enumerator(MyCollection enumerable)
        {
            source = enumerable.source;
            index = -1;
        }

        // public property
        public int Current
            => source[index];

        // explicit IEnumerator implementation
        object IEnumerator.Current
            => Current;

        public bool MoveNext()
            => ++index < source.Length;

        public void Reset()
            => index = -1;
    }
}
```

The only differences are:

- The collection derives from `IEnumerable`.
- `GetEnumerator()` must return `IEnumerator`.
- The enumerator derives from `IEnumerator`.
- The enumerator must have a `Reset()` method.

Notice that `IEnumerator` requires the property `Current` to return the type `object`. I want it to return `int` as it's the type of the item for this collection. Its possible to have both implementations, one public and the other use explicit interface implementation. The explicit implementation property is only used when the enumerator is cast to `IEnumerator`.

> If the enumerator does not support resetting, it should throw a `NotSupportedException`.

[You can see in SharpLab that the generated code for a `foreach` statement is the following](https://sharplab.io/#v2:EYLgxg9gTgpgtADwGwBYA+ABATABgLABQ2AjIRjgAQbEB0AwhADaMxgAuAlhAHYDOA3IUIA3AIZQKvCAFcoYGBQC8FbjADuFALIBPBs1aceAClVqA2gF0KAbxwAaCsQdYHAZgcoAvgEpBBAGbQMKJgABZGHNxsFBxsMAC2MdySMnIw3oQUWVTEAJwRcfG+QkRYWrpMLOxcySA5roTWmdmwogAmPIzaSWyWKbLyftkUzVkYruV6VYbcEVF9UgPpo8NKAHwUbKEcvDSLaUr9aUPZK+MUAJIAotzS8TBQomzQFADiMGw3dw9P0EYZBFW2UUG1MFC+90ezygRi2O2KgNOiLGE14bCg0nY4NukN+Ejq1xxP2hKyayNWrQ63C6PQWqUGK2GkWikTaMAQJyBjOy5whxL+OimBhqFBgRMewBYAKBWTJMtW+3khzF3wlLD29JgnPlSTZCEOcGI2uGnm5WTNVAmEGAACsDBQ6LJYFERuT5SCjvIzKz2RZjTKLedgBAmFoIMIYAA5dlsf4W4YegDUiZ9+oAPJ6YDQADJigDmW39XLdPImGBQFAASjBeB84yWgR7UwajStTQR24QgA==):

```csharp
IEnumerator enumerator = new MyCollection(array).GetEnumerator();
try
{
    while (enumerator.MoveNext())
    {
        Console.WriteLine((int)enumerator.Current);
    }
}
finally
{
    IDisposable disposable = enumerator as IDisposable;
    if (disposable != null)
    {
        disposable.Dispose();
    }
}
```

Several things to notice:

- The enumerator is returned as type `IEnumerator`, which is a reference-type.
- The value returned by `Current` has to be cast to int because it's using the explicit implementation.
- Although the enumerator doesn't implement `IDispose`, it adds code to check at runtime if it does.

I mentioned above that enumerators should have a value-type enumerator for better performance. We see here that by returning `IEnumerator`, the enumerator is boxed, which converts it into a reference-type. The way to workaround this is to also use explicit interface implementation for the method `GetEnumerator()`:

```csharp
class MyCollection : IEnumerable
{
    readonly int[] source;

    public MyCollection(int[] source)
        => this.source = source;

    // public method
    public Enumerator GetEnumerator()
        => new Enumerator(this);

    // explicit IEnumerable implementation
    IEnumerator IEnumerable.GetEnumerator()
        => GetEnumerator();

    public struct Enumerator : IEnumerator
    {
        readonly int[] source;
        int index;

        public Enumerator(MyCollection enumerable)
        {
            source = enumerable.source;
            index = -1;
        }

        public int Current
            => source[index];

        object IEnumerator.Current
            => Current;

        public bool MoveNext()
            => ++index < source.Length;

        public void Reset()
            => index = -1;
    }
}
```

[You can see in SharpLab that now the generated code for a `foreach` statement is the following](https://sharplab.io/#v2:EYLgxg9gTgpgtADwGwBYA+ABATABgLABQ2AjIRjgAQbEB0AwhADaMxgAuAlhAHYDOA3IUIA3AIZQKvCAFcoYGBQC8FbjADuFALIBPBs1aceAClVqA2gF0KAbxwAaCsQdYHAZgcoAvgEpBBAGbQMKJgABZGHNxsFBxsMAC2MdySMnIw3oQUWVTEAJwRcfG+QkRYWrpMLOxcySA5roTWmdmwogAmPIzaSWyWKbLyftkUzVkYruV6VYbcEVF9UgPpo8NKAHwUbKEcvDSLaUr9aUPZK+MUAKLc0vEwUKJs0BQA4jBsVzd3D9BGGQSr2UUG1Ml2ut3ujygRi2O2K/wBI3hWQAkh9wd8JNRXDRXu8wV9Ib8VsMgS83miCT84cMzhNeGwoNJ2KDPhCnnVUfi2VAVk0katWh1uF0egtUoNidlItFIm0YAgTgDJWMJhTuUYdFMDDUKDAuaJgCw/gibMrVvt5Ic9ayDSw9uKYIqTUk5QhDnBiE7hp4zWbztKKHRZLAoojnYCNhaYGZZfKLF6EWaIMAAFYGCicm2Q+jBvVsM0kjZBqAhtgJpX84bnYAQJhaCDCGAAOXlbCJlYRpIA1F3Y26ADxHeQ0AAyeoA5lty6s/RMMCgKAAlGC8N7t8NZUl992elY+gj7whAA==):

```csharp
MyCollection.Enumerator enumerator = new MyCollection(array).GetEnumerator()
while (enumerator.MoveNext())
{
    Console.WriteLine(enumerator.Current);
};
```

It uses the value type enumerator. It will only use the reference-type enumerator if the collection is cast to `IEnumerable`.

> All collections provided by .NET provide a value-type enumerator. You should do the same if you implement your own collection.

## IEnumerable<T>

`IEnumerable<T>` and `IEnumerator<T>` extend the pair of interfaces `IEnumerable` and `IEnumerator` to specify the type of item returned by the `Current` property.

Because `IEnumerable<T>` derives from `IEnumerable`, and `IEnumerator<T>` derives from `IEnumerator` and `IDispose`, the example collection should be implemented as follow:

```csharp
class MyCollection : IEnumerable<int>
{
    readonly int[] source;

    public MyCollection(int[] source)
        => this.source = source;

    // public method
    public Enumerator GetEnumerator()
        => new Enumerator(this);

    // explicit IEnumerable<T> implementation
    IEnumerator<int> IEnumerable<int>.GetEnumerator()
        => GetEnumerator();

    // explicit IEnumerable implementation
    IEnumerator IEnumerable.GetEnumerator()
        => GetEnumerator();

    public struct Enumerator : IEnumerator<int>
    {
        readonly int[] source;
        int index;

        public Enumerator(MyCollection enumerable)
        {
            source = enumerable.source;
            index = -1;
        }

        public int Current
            => source[index];

        object IEnumerator.Current
            => Current;

        public bool MoveNext()
            => ++index < source.Length;

        public void Reset()
            => index = -1;

        public void Dispose() {}
    }
}
```

[You can see in SharpLab that now the generated code for a `foreach` statement is the following](https://sharplab.io/#v2:EYLgxg9gTgpgtADwGwBYA+ABATABgLABQ2AjIRjgAQbEB0AwhADaMxgAuAlhAHYDOA3GUrUUggoQBuAQygVeEAK5QwMCgF4K3GAHcKAWQCeDZq048AFFu0BtALoUA3jgA0FYq6yuAzK5QBfAEoxADNoGCkwAAtzDm42Cg42GABbBO45RWUYAMIKPKpiAE4YpOSgwjIsfSMmFnYudJACrwAeWLYAPkIHXPzYKQATHkYDNLY7DKUVMXyKXryML2rjOrNuGLiJ+Sns+dn1Doo2SI5eGm2s9Umsmfy9xYoAUW4FZJgoKTZoCgBxGDZnq93p9oOYcgR9vk1IcrE8Xm8Pl8oOZjqdyhDIXMMXkAJKAhEgqBtOKHaitdodGh/AHw4FIsF7WbQ37/fF00FBPKMu7Yih42mI75kqmsgWEhm8pmHalswXI9Gze5LXhsKAKdhwoFyihNflawnEzp7HqSvrhIbcEZjLaZabcvLtNIDGAIW6Q+1UJay8WGFamBoUGBi4AscGYxwe2YXFRXIP6kMwc62mBu8NOl1XODEVOzPwej0PR10JSwOJYtNQw7RmDWWLOhC2HOYj0QYAAK1MfO9SPoJaDbEjlYoxagpbYTfdpoWS2AECY+ggEhgADkXWwJRW8syANTbusZlrXFQ0AAyQYA5scJ/sC0sMCgKAAlGC8f4bzfM/cITPZwdcqeelQD4ACKnAADhAr5go4ea8rBsGEEAA=):

```csharp
MyCollection.Enumerator enumerator = new MyCollection(array).GetEnumerator()
try
{
    while (enumerator.MoveNext())
    {
        Console.WriteLine(enumerator.Current);
    }
}
finally
{
    ((IDisposable)enumerator).Dispose();
};
```

The differences are:

- The enumerator is a value-type.
- The value returned by `Current` doesn't require a cast. This improves performance as it was being done for each item.
- `Dispose()` is called even though it's empty. It's `IEnumerator<T>` that makes the `Dispose()` mandatory.

The `Dispose()` call can be avoided by declaring two enumerators for the collection:

```csharp
class MyCollection : IEnumerable<int>
{
    readonly int[] source;

    public MyCollection(int[] source)
        => this.source = source;

    public Enumerator GetEnumerator()
        => new Enumerator(this);

    IEnumerator<int> IEnumerable<int>.GetEnumerator()
        => new ReferenceEnumerator(this);

    IEnumerator IEnumerable.GetEnumerator()
        => new ReferenceEnumerator(this);

    // value type enumerator
    public struct Enumerator
    {
        readonly int[] source;
        int index;

        public Enumerator(MyCollection enumerable)
        {
            source = enumerable.source;
            index = -1;
        }

        public int Current
            => source[index];

        public bool MoveNext()
            => ++index < source.Length;
    }

    // reference type enumerator
    class ReferenceEnumerator : IEnumerator<int>
    {
        readonly int[] source;
        int index;

        public ReferenceEnumerator(MyCollection enumerable)
        {
            source = enumerable.source;
            index = -1;
        }

        public int Current
            => source[index];

        object IEnumerator.Current
            => Current;

        public bool MoveNext()
            => ++index < source.Length;

        public void Reset()
            => index = -1;

        public void Dispose() {}
    }
}
```

Thing that changed:

- The public `GetEnumerator()` returns an instance of the value-type enumerator while the other ones return instances of the reference-type enumerator.
- The value-type enumerator only implements the minimum requirements.
- The reference-type enumerator is declared as private as it's only used internally.
- The reference-type enumerator is declared as a class. This avoids the boxing performance penalty of converting from value-type to reference-type.

[You can see in SharpLab that the generated code for the `foreach` statement if the following](https://sharplab.io/#v2:EYLgxg9gTgpgtADwGwBYA+ABATABgLABQ2AjIRjgAQbEB0AwhADaMxgAuAlhAHYDOA3GUrUUggoQBuAQygVeEAK5QwMCgF4K3GAHcKAWQCeDZq048AFFu0BtALoUA3jgA0FYq6yuAzK5QBfAEoxADNoGCkwAAtzDm42Cg42GABbBO45RWUYAMIKPKpiAE4YpOSgwjIsfSMmFnYudJACrwAeWLYAPkIHXPzYKQATHkYDNLY7DKUVMXyKXryML2rjOrNuGLiJ+Sns+dn1Doo2SI5eGm2s9Umsmfy9xYoAUW4FZJgoKTZoCgBxGDZnq93p9oOYcgR9vk1IcrE8Xm8Pl8oOZjqdyhDIXMMXkAJKAhEgqBtOKHaitdodGh/AHw4FIsF7WbQzQ6CgAJRgwXeMG4KnxdNBqN46MxWNmeNpiO+ZKp/35UuR4NFzNhHK5sF5MHlhJRJ2Ftzy9yWvDYUAU7DhQIVex62P2/SG3BGYy2mWmjPy7TSAxgCAN+w9CyW2vphhWpgaFB5VqkwBYSsxttFswuKiu0YJcZg5zdMH9otiPoQVzgxHz+T8gbFmIeXroSg18SrTMOqZg1kLvts5chVYewAgTH0EAkMAAcr62Ay7crDgBqOed4sta4qGgAGR5AHNjmI9n47jPD7NsOzOdzNSHvk0JTGkcTOjaqw7hqN2q6dj2xt7fV++0s1QvPlJR1MNagjHgoxArME0hJNkzyNt02glgc0/ZtPW4IsSzLKtKyPQ0CKoJY6wbHkmyIltV3bJduwwwjRQgYAACtTAoW8CSRegyLieiDgoesoEbL9Zn/CgByHPQR3HSdpwQvJmQXJcKBXNsN23Xc+LEjAUDPXh/jk+TmWUjRSxE48ayWHSKAAEVOAAHCB9LBRx8NmfD8IqAggA=):

```csharp
MyCollection.Enumerator enumerator = new MyCollection(array).GetEnumerator()
while (enumerator.MoveNext())
{
    Console.WriteLine(enumerator.Current);
};
```

The advantage is that without the `try`/`finally` blocks the JIT compiler may be able to perform more optimizations resulting in better performance.

## Arrays and Span<T>

Arrays and `Span<T>` are types of collections where the data is stored in a contiguous portion of memory. These are exceptions on how `foreach` deals with them. Instead of using an enumerator, it uses the indexer which performs much better.

[You can see in SharpLab that the generated code for a `foreach` statement with an array as source is the following](https://sharplab.io/#v2:EYLgxg9gTgpgtADwGwBYA+ABATABgLABQ2AjIYQG4CGUABAM4QCuUYMNAvDQHYwDuA2gF0aAbxwAaGsUlZJAZkkoAvgG4yBAGbQYlMAAsAFFVoBLAC4wAtjRNd6TFjACUhGm5oZiATgPmrTtQIgA):

```csharp
int[] array2 = array
int num = 0;
while (num < array2.Length)
{
    Console.WriteLine(array2[num]);
    num++;
};
```

> Please check my other article "Array iteration performance in C#" where I analyze into more detail this case.

The only issue with using `foreach` on arrays is that it only allows full traversal. If you want to traverse only a portion of the array, you can create an instance of `ArraySegment<T>` or `Span<T>` and use `foreach` to traverse it.

Both `Span<T>` and `ReadOnlySpan<T>` support passing items by reference. Don't forget to use the `ref` keyword when traversing these types using foreach.

> [I've implemented a Roslyn Analyzer](https://github.com/NetFabric/NetFabric.Hyperlinq.Analyzer) that includes a rule that warns you when ref and ref readonly can be used. Install it to get this and several many other rules related to the used of foreach.

# Conclusions

`foreach` has a very simple and clear syntax. We saw here that the C# compiler adapts the generated code to the type of collection.

When declaring a new collection type, you should adjust its enumeration code so that `foreach` can take full advantage of it.
